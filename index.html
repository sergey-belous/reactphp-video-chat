<!-- index.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Group Video Call</title>
    <style>
        #videos {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 10px;
        }
        video {
            width: 100%;
            background: #000;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div id="videos"></div>

    <script>
        const config = {
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        };
        const peerConnections = {}; // userId -> RTCPeerConnection
        let localStream;
        let socket;
        let roomId = 'room1';
        let userId = Math.random().toString(36).substring(2, 10);
        const userVideoElems = {}; // userId -> videoElem

        async function init() {
            localStream = await navigator.mediaDevices.getUserMedia({
                video: true,
                audio: true
            });
            const videosDiv = document.getElementById('videos');
            // Add local video
            const localVideo = document.createElement('video');
            localVideo.autoplay = true;
            localVideo.muted = true;
            localVideo.srcObject = localStream;
            videosDiv.appendChild(localVideo);
            userVideoElems[userId] = localVideo;

            // WebSocket connect
            //socket = new WebSocket('wss://'+window.location.hostname+'/ws/');
            socket = new WebSocket('wss://176.98.176.46/ws/');
            socket.onmessage = handleMessage;
            socket.onopen = () => {
                socket.send(JSON.stringify({
                    type: 'join-request',
                    room: roomId,
                    userId: userId
                }));
            };
            socket.onclose = () => { alert('Connection lost'); };
        }

        window.onload = init;

        function handleMessage(msg) {
            const data = JSON.parse(msg.data);
            switch (data.type) {
                case 'initial-peers':
                    data.peers.forEach(remoteId => {
                        createPeer(remoteId, true);
                    });
                    break;
                case 'user-joined':
                    createPeer(data.userId, false);
                    break;
                case 'user-left':
                    closePeer(data.userId);
                    break;
                case 'signal':
                    handleSignal(data.from, data.data);
                    break;
            }
        }

        function createPeer(remoteId, isInitiator) {
            if (peerConnections[remoteId]) return; // already exists
            const pc = new RTCPeerConnection(config);
            localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

            pc.ontrack = e => {
                if (!userVideoElems[remoteId]) {
                    const v = document.createElement('video');
                    v.autoplay = true;
                    v.srcObject = new MediaStream();
                    userVideoElems[remoteId] = v;
                    document.getElementById('videos').appendChild(v);
                }
                e.streams[0].getTracks().forEach(track => {
                    userVideoElems[remoteId].srcObject.addTrack(track);
                });
            };
            pc.onicecandidate = e => {
                if (e.candidate) {
                    socket.send(JSON.stringify({
                        type: 'signal',
                        room: roomId,
                        userId: userId,
                        to: remoteId,
                        data: { type: 'ice', candidate: e.candidate }
                    }));
                }
            };
            peerConnections[remoteId] = pc;

            if (isInitiator) {
                pc.onnegotiationneeded = async () => {
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    socket.send(JSON.stringify({
                        type: 'signal',
                        room: roomId,
                        userId: userId,
                        to: remoteId,
                        data: { type: 'offer', sdp: offer }
                    }));
                };
            }
        }

        async function handleSignal(fromId, signal) {
            let pc = peerConnections[fromId];
            if (!pc) {
                createPeer(fromId, false);
                pc = peerConnections[fromId];
            }
            if (signal.type === 'offer') {
                await pc.setRemoteDescription(signal.sdp);
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                socket.send(JSON.stringify({
                    type: 'signal',
                    room: roomId,
                    userId: userId,
                    to: fromId,
                    data: { type: 'answer', sdp: answer }
                }));
            } else if (signal.type === 'answer') {
                await pc.setRemoteDescription(signal.sdp);
            } else if (signal.type === 'ice') {
                try {
                    await pc.addIceCandidate(signal.candidate);
                } catch (e) { }
            }
        }

        function closePeer(remoteId) {
            if (peerConnections[remoteId]) {
                peerConnections[remoteId].close();
                delete peerConnections[remoteId];
            }
            if (userVideoElems[remoteId]) {
                userVideoElems[remoteId].remove();
                delete userVideoElems[remoteId];
            }
        }
    </script>
</body>
</html>
